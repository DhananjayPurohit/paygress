# Paygress Native .so Shared Library Plugins

🔧 **Maximum Performance: Native shared libraries loaded directly into ingress controllers**

Your Rust code compiles to `.so` files that get loaded as **native modules** - this gives you **true C-level performance** with **zero overhead**.

## 🏗️ Architecture Comparison

### **.so Plugins (Maximum Performance)** ⚡
```
┌─────────────────────────────────────────────────────────┐
│                Ingress Controller Process               │
│  ┌─────────────────────────────────────────────────────┐ │
│  │              Native Code Space                      │ │
│  │  ┌─────────────┐    ┌─────────────┐    ┌─────────┐  │ │
│  │  │ NGINX Core  │    │ Traefik Core│    │Envoy Core│ │ │
│  │  │             │    │             │    │         │ │ │
│  │  │ ┌─────────┐ │    │ ┌─────────┐ │    │ ┌─────┐ │ │ │
│  │  │ │Paygress │ │    │ │Paygress │ │    │ │Payg.│ │ │ │
│  │  │ │.so      │ │    │ │.so      │ │    │ │.so  │ │ │ │
│  │  │ │(Rust)   │ │    │ │(Rust)   │ │    │ │(Rust)│ │ │ │
│  │  │ └─────────┘ │    │ └─────────┘ │    │ └─────┘ │ │ │
│  │  └─────────────┘    └─────────────┘    └─────────┘ │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### **WASM Plugins (Near-Native)** 🚀
```
┌─────────────────────────────────────────────────────────┐
│                Ingress Controller Process               │
│  ┌─────────────────────────────────────────────────────┐ │
│  │              WASM Runtime                           │ │
│  │  ┌─────────────┐    ┌─────────────┐    ┌─────────┐  │ │
│  │  │ NGINX       │    │ Traefik     │    │ Envoy   │ │ │
│  │  │ + WASM VM   │    │ + WASM VM   │    │ + WASM  │ │ │
│  │  │ ┌─────────┐ │    │ ┌─────────┐ │    │ ┌─────┐ │ │ │
│  │  │ │Paygress │ │    │ │Paygress │ │    │ │Payg.│ │ │ │
│  │  │ │.wasm    │ │    │ │.wasm    │ │    │ │.wasm│ │ │ │
│  │  │ └─────────┘ │    │ └─────────┘ │    │ └─────┘ │ │ │
│  │  └─────────────┘    └─────────────┘    └─────────┘ │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

## 🚀 Build Native .so Plugins

```bash
# Build all .so plugins
./build-so-plugins.sh

# Or build individually:
cargo build --release --features nginx-so --lib
# Creates: target/release/libpaygress.so → plugins/nginx/ngx_http_paygress_module.so
```

## 📊 Performance Comparison

| Plugin Type | Performance | Memory | Startup | Hot Reload | Security |
|-------------|-------------|--------|---------|------------|----------|
| **.so Native** | ⚡⚡⚡ **100%** | Low | Instant | ❌ | Native |
| **WASM** | ⚡⚡ **~95%** | Medium | Fast | ✅ | Sandboxed |
| **External Service** | ⚡ **~60%** | High | Slow | ✅ | Isolated |

## 🔧 Integration Methods

### **1. NGINX Ingress Controller - Native Module**

**How .so gets imported:**
```nginx
# Auto-generated by ingress controller
load_module modules/ngx_http_paygress_module.so;  # ← Your Rust library!

http {
    location /premium {
        # Direct C function call - ZERO overhead!
        access_by_lua_block {
            local ffi = require("ffi")
            local paygress = ffi.load("/etc/nginx/modules/ngx_http_paygress_module.so")
            local result = paygress.ngx_http_paygress_verify_payment(token, 1000)
        }
    }
}
```

**Deploy:**
```bash
kubectl apply -f k8s/nginx-so-plugin.yaml
```

### **2. Traefik - Go Plugin with Rust .so**

**How .so gets imported:**
```go
// Traefik Go plugin that calls your Rust .so
// #cgo LDFLAGS: -lpaygress
// extern int ngx_http_paygress_verify_payment(const char* token, int amount);
import "C"

func (p *PaygressPlugin) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
    token := getAuthToken(req)
    result := C.ngx_http_paygress_verify_payment(C.CString(token), C.int(amount))
    // Direct C call to your Rust code!
}
```

**Build:**
```bash
cd plugins/traefik
go build -buildmode=plugin -o paygress.so
```

### **3. Envoy/Istio - C++ Extension with Rust .so**

**How .so gets imported:**
```cpp
// Envoy C++ filter that calls your Rust .so
extern "C" {
    int ngx_http_paygress_verify_payment(const char* token, int amount);
}

FilterHeadersStatus PaygressFilter::decodeHeaders(RequestHeaderMap& headers, bool) {
    std::string token = getAuthToken(headers);
    int result = ngx_http_paygress_verify_payment(token.c_str(), amount_);
    // Direct C call to your Rust code!
}
```

## 🎯 .so Plugin Advantages

### **Maximum Performance:**
- ✅ **Native C speed** - no WASM interpretation
- ✅ **Zero function call overhead** - direct FFI
- ✅ **Direct memory access** - no serialization
- ✅ **CPU cache friendly** - native code layout

### **System Integration:**
- ✅ **Full system access** - no sandbox restrictions
- ✅ **Direct Kubernetes API** - native HTTP clients
- ✅ **File system access** - native I/O
- ✅ **Network sockets** - direct system calls

### **Memory Efficiency:**
- ✅ **Shared library** - loaded once per process
- ✅ **No WASM runtime** - no interpreter overhead
- ✅ **Native allocator** - direct malloc/free
- ✅ **Zero-copy operations** - direct pointer access

## ⚠️ .so Plugin Considerations

### **Deployment Complexity:**
- ❌ **Platform specific** - need different .so for different architectures
- ❌ **No hot reload** - requires ingress controller restart
- ❌ **Version management** - careful ABI compatibility
- ❌ **Debug complexity** - harder to troubleshoot crashes

### **Security:**
- ⚠️ **Full process access** - can crash entire ingress controller
- ⚠️ **No sandboxing** - unrestricted system access
- ⚠️ **Memory safety** - Rust helps but FFI is unsafe

## 🚀 Quick Start

### **1. Build your .so plugin:**
```bash
# Build for your platform
./build-so-plugins.sh

# Check output
ls plugins/nginx/ngx_http_paygress_module.so
ls plugins/traefik/paygress.so
ls plugins/envoy/paygress_filter.so
```

### **2. Deploy to NGINX:**
```bash
# Deploy native module
kubectl apply -f k8s/nginx-so-plugin.yaml

# Test
curl -H "Authorization: Bearer <cashu-token>" http://api.example.com/premium
```

### **3. Monitor performance:**
```bash
# Check NGINX performance
kubectl top pods -n ingress-nginx

# Monitor .so module
kubectl logs -n ingress-nginx deployment/ingress-nginx-controller -f
```

## 📋 When to Use .so vs WASM

### **Use .so Native Plugins When:**
- ✅ **Maximum performance required** (high-traffic production)
- ✅ **Complex system integration needed** (K8s API, file system)
- ✅ **Stable deployment environment** (controlled updates)
- ✅ **Team has C FFI experience**

### **Use WASM Plugins When:**
- ✅ **Hot reload important** (development/testing)
- ✅ **Security isolation required** (untrusted code)
- ✅ **Cross-platform deployment** (multiple architectures)
- ✅ **Easier debugging needed**

## 🎉 Result: True Native Integration

Your Rust code now runs as a **native shared library** inside the ingress controller:

- 🔧 **NGINX**: `load_module ngx_http_paygress_module.so`
- 🟣 **Traefik**: Go plugin calls your `.so` via CGO
- 🟢 **Envoy**: C++ extension calls your `.so` via FFI

**This is as close to native as you can get while still being a "plugin"!** ⚡

Your Cashu payment verification now runs at **true C speed** inside the ingress controller process. 🦀🚀
